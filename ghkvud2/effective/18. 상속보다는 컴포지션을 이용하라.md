## 18. 상속보다는 컴포지션을 이용하라

### 1. 상속은 캡슐화를 깨뜨린다.

- 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.
- 상위 클래스에 메소드를 추가했을 경우, 그 메소드를 재정의하지 않아 이상이 생길 수 있다.
  1. 하위 클래스를 통해 상위 클래스에 있는 컬렉션에 원소를 추가할 때 특정 조건을 만족하는 원소만 추가할 수 있도록 로직이 변경되어야 한다고 가정하자.
  2. 하위 클래스가 재정의한 모든 메소드에 조건을 만족하는지 확인하는 로직을 추가하면 될 것 같다.
  3. 하지만, 상위 클래스에서 컬렉션에 원소를 추가하는 메소드가 새로 생겼을 때, 하위 클래스에서 이 메소드를 재정의하지 않는다면 조건에 만족하지 않는 원소도 상위 클래스의 메소드를 통해 컬렉션에 추가될 수 있다.



### 2. 기존 클래스를 상속하는 대신 참조하도록 하자.

- 기존 클래스를 상속하는 대신에 새로운 클래스를 만들고 private 필드로 기존 클래스를 참조하도록 하는 필드를 선언하자. (기존 클래스가 새로운 클래스의 구성 요소로 쓰인다는 뜻에서 `컴포지션`이라한다.)
- 새로운 클래스의 메소드들은 기존 클래스의 대응하는 메소드를 호출해 그 결과를 반환한다.
- 새로운 클래스는 기존 클래스의 내부 구현 방식에서 벗어날 수 있고 기존 클래스에 새로운 메소드가 추가되더라도 영향을 받지 않는다.



### 3. IS-A 관계에서만 상속을 사용하라.

- 상속은 반드시 하위 클래스가 상위 클래스의 "진짜" 하위 타입은 경우에서만 쓰여야한다.
- A 클래스를 상속하려는 B 클래스를 작성하려고 한다면, "B가 A인가?"라고 자문해봐야 한다. "그렇다"고 확신할 수 없으면 B는 A를 상속해선 안된다.
- A를 private 인스턴스로 두고 A와는 다른 API를 제공해야 하는 상황이 대다수다.