## 제네릭2

### 1. 제네릭을 사용하는 이유는?

- 다양한 타입의 매개변수에 대해서 똑같은 로직을 수행할 수 있도록한다.

  - 두 매개변수를 더하는 메소드 `add` 가 있을 때, int, double, string 타입 매개변수를 `+` 하는 메소드를 여러 개 만드는 것이 아니라 하나의 메소드로 똑같은 로직을 수행할 수 있게 한다.

  ```java
  public int add(int x, int b) { return x + y;}
  public double add(double x, double b) { return x + y;}
  public String add(String x, String b) { return x + y;}
  
  //아래처럼 하나의 메소드로 여러 타입에 대해서 같은 로직을 수행할 수 있음
  public <T> T add(T x, T y) {return x+ y;}
  ```

  

1. Parametric Polymorphism

   - 제네릭이 Parametric Polymorphism의 예시라고 할 수 있다.
   - 서로 다른 매개변수 타입에 대해서 같은 로직을 수행할 수 있도록 하는 방법이다.

2. ad hoc Polymorphism

   - `ad hoc Polymorphism`은 똑같은 이름을 가진 메소드가 서로 다른 타입에 대해서 다르게 동작할 수 있도록 하는 방식이다. (오버로딩)

   

### 2. 제네릭의 이점은?

1. 제네릭은 컴파일 시점에 타입 체크를 하기 때문에 런타임에 발생할 수 있는 오류를 컴파일 시점에 미리 발견할 수 있도록 한다.
2. 불필요한 타입 캐스팅을 방지할 수 있다. 컴파일러가 캐스팅하는 코드를 자동으로 넣어준다.
3. 파라미터 다형성을 적용해 다른 타입 매개변수에 대해서 같은 로직을 실행할 수 있도록 한다.



### 3.  변성,  무공변성, 공변성, 반공변성

1. 변성(Variance)

2. 불공변성 (Invariance)

   - 타입 S가 타입 T의 하위 타입일 때, M&lt;S&gt; 와 M&lt;T&gt; 사이에 상속 관계가 없는 것을 말한다.

   - Number 클래스는 Double의 상위 타입이기 때문에 아래 코드는 문제가 없다.

     ```java
     Double d = 1.1;
     Number n = d;
     ```

   - 그러나, Number가 Double의 상위 타입이지만 List&lt;Number&gt; 와 List&lt;Double>은 어떤 관계도 아니다.

     ```java
     List<Double> ld = new ArrayList<>();
     List<Number> ln = ld; // 컴파일 에러
     ```

   

   - 타입 소거 (Type Erasure)

     - 자바에서 제네릭의 문제점은 하위 버전으 코드들과의 호환성을 위해서 컴파일 이후에 `타입 파라미터` 정보가 제거되어 런타임 시점에는 타입 파라미터 정보를 알 수 없다.

     - 즉, JVM은 List&lt;Double&gt;과 List&lt;Number&gt; 는 런타임 시점에는 똑같이 List 타입으로 인지한다.

       ```java
       1) List<Integer> myInts = newArrayList<Integer>();
       2) myInts.add(1);
       3) myInts.add(2);
       4) List<Number> myNums = myInts; //컴파일 에러
       5) myNums.add(3.14); 
       ```

       - 4번 라인에서 컴파일 오류를 발생시키지 않는다고 가정하면 런타임시에도 에러는 발생하지 않는다.
       - 타입 소거에 의해서 모든 타입 파라미터 정보가 삭제될 것이기 때문에 5번 라인의 코드는 List raw 타입에 Double 타입의 값을 넣는 것과 같기 때문에 에러라고 판단할 수 없다.
       - 다만, myNums 리스트에서 get() 메소드를 통해 타입 캐스팅을 할 때 CastException이 발생할 것이다.

3. 공변성 (Covariance)

   - 대표적으로 배열이 공변성을 가진다고 할 수 있는데, 타입 S가 타입 T의 하위 타입일 때 M&lt;S>도 M&lt;T>의 하위 타입인 경우이다.

     ```JAVA
     Integer[] i = {1,2,3,4};
     Number[] n = i;
     ```

     - Number가 Integer의 상위 타입이기 때문에 Number[]도 Integer[]의 상위 타입이 될 수 있다.

     ```java
     n[0] = 3.14; // 런타임 에러
     ```

     - 이 코드는 컴파일 시점에는 에러가 발생하지 않지만 Integer형 배열에 Double 값을 넣으려고 했기 때문에 런타임 시점에 에러가 발생한다.
     - 즉, 공변의 경우에는 컴파일 시점에 타입 체크를 할 수 없다.

     

   - 클래스의 상속 관계가 제네릭에서도 유지될 수 있도록 하기 위해서는 `Upper Bounded Wildcard`를 사용하면된다.

     ```java
     List<Number> n = new List<Integer>(); // 컴파일 에러
     
     List<? extends Number> i = new ArrayList<Integer>(); //정상
     ```

     ```java
     Number number = i.get(0);
     ```

     - 이 경우에는 실제 구현체가 어떤 파라미터 타입이든지간에 Number의 하위 타입(Integer, Double, Float)이므로 값을 읽어올 수 있다.

     ```java
     i.add(45L); //컴파일 에러
     ```

     - 그러나 컴파일러는 실제 타입이 무엇인지 알 수 없기 때문에 위처럼 값을 추가할 수는 없다. 
     - 실제 구현체는 Number의 하위 타입인 Integer, Double, Float 중 정확히 어떤 타입인지인지 알 수 없기 때문이다.

4. 반공변성 (Contravariance)

   - S가 T의 하위 타입일 때, M&lt;T>가 M&lt;S>의 하위 타입인 경우를 말한다.

   - `Lower Bounded Wildcard`를 사용해서 나타낼 수 있다.

     ```java
     Number number = Double.of(1.1);
     ```

     ```java
     List<Number> numbers = Arrays.asList(1.1, 2, 3L);
     List<? super Double> list = numbers;
     
     Double d = list.get(0); // 컴파일 에러
     ```

     - Number가 Double의 상위 타입일 때 List&lt;Number>가 List&lt;Double> 의 하위 타입임을 나타내기위해서는 `<? super Double>`로 표현할 수 있다.
     - 원소를 가져올 때 컴파일 에러가 나는 이유는 list에서 저장된 요소들은 Double 클래스의 모든 상위 클래스가 될 수 있으므로 특정 타입으로 정할 수 없기 때문이다.